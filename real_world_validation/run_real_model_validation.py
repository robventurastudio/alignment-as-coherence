"""High-level orchestration for real-world coherence validation."""

from __future__ import annotations

from typing import Any, Dict, Optional

import numpy as np

from alignment_faking_phase_diagram import (
    analyze_multiscale_structure,
    compute_lyapunov_exponent,
    detect_hidden_islands,
    find_critical_training_strength,
)

from .load_sae_features_stub import SAEFeatureBundle, load_sae_features
from .map_to_fields_stub import CoherenceFieldSet, map_features_to_fields


class ValidationResult(Dict[str, Any]):
    """Dictionary-like container for downstream reporting."""


def _sanitize_fields(fields: CoherenceFieldSet) -> None:
    """Run basic validation helpers before invoking the diagnostics."""

    fields.ensure_unit_shape()
    fields.validate_monotonic_axis()


def run_real_model_validation(project_root: Optional[str] = None) -> ValidationResult:
    """Execute the full validation pipeline against real SAE activations.

    Parameters
    ----------
    project_root : Optional[str]
        Optional path or experiment identifier passed through to
        :func:`load_sae_features`.

    Returns
    -------
    ValidationResult
        A dictionary of metrics generated by the existing diagnostics. Each
        entry contains the raw outputs so that labs can build their own
        reporting layers or dashboards on top of this scaffold.

    Notes
    -----
    The helper functions imported from :mod:`alignment_faking_phase_diagram`
    expect numpy arrays corresponding to the deep, surface, and target fields.
    Replace the placeholder loading/mapping routines with concrete
    integrations to evaluate actual model checkpoints.
    """

    bundle: SAEFeatureBundle = load_sae_features(project_root)
    bundle.validate_shapes()

    fields: CoherenceFieldSet = map_features_to_fields(bundle)
    _sanitize_fields(fields)

    validation_payload = ValidationResult()
    validation_payload["bundle_metadata"] = dict(bundle.metadata or {})
    validation_payload["bundle_index"] = [int(idx) for idx in bundle.feature_index]
    validation_payload["field_metadata"] = {
        "normalization": fields.normalization,
        "x_axis_summary": {
            "min": float(np.min(fields.x_axis)),
            "max": float(np.max(fields.x_axis)),
            "num_points": int(fields.x_axis.size),
        },
    }

    validation_payload["hidden_islands"] = detect_hidden_islands(
        fields.v_deep, fields.v_surface
    )
    validation_payload["critical_training_strength"] = find_critical_training_strength(
        fields.v_deep, fields.v_surface, fields.v_target
    )
    validation_payload["lyapunov_exponent"] = compute_lyapunov_exponent(
        fields.v_deep, fields.v_surface
    )
    validation_payload["multiscale_structure"] = analyze_multiscale_structure(
        fields.v_deep, fields.v_surface
    )

    validation_payload["inputs"] = {
        "bundle": bundle.to_serializable(),
        "fields": fields.to_serializable(),
    }

    return validation_payload


__all__ = ["run_real_model_validation", "ValidationResult"]
